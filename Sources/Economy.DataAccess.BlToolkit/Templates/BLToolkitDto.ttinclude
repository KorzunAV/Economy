<#@ assembly name="System.Core"    #>
<#@ assembly name="System.Data"    #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO"   #>
<#
	AppDomain.CurrentDomain.AssemblyResolve += (_,args) =>
	{
		foreach (var a in Assemblies)
			if (args.Name.ToLower().IndexOf(a.Key.ToLower()) >= 0)
				return System.Reflection.Assembly.LoadFile(a.Value);
	
		if (DataProviderAssembly != null && args.Name.Split(',')[0] == System.IO.Path.GetFileNameWithoutExtension(DataProviderAssembly))
			return System.Reflection.Assembly.LoadFile(DataProviderAssembly);

		return null;
	};
#><#+

static Dictionary<string,string> Assemblies = new Dictionary<string,string>();

static Action<GeneratedTextTransformation,string> WriteSummary        = (tt,s) => 
{
	if (!string.IsNullOrWhiteSpace(s))
	{
		tt.WriteLine("/// <summary>");
		tt.WriteLine("/// {0}", s);
		tt.WriteLine("/// </summary>");
	}
};

static string ConnectionString;
static string ConnectionType;
static string DataProviderAssembly = null;

string DatabaseName             = "economy";
string DataContextName          = null;
string Namespace                = "DataModel";
string BaseDataContextClass     = null;
string BaseEntityClass          = "BaseEntity";
string OneToManyAssociationType = "IEnumerable<{0}>";

string OwnerToInclude           = null;
string[] DatabaseQuote          = null;

bool   RenderField              = false;
bool   RenderBackReferences     = false;
bool   RenderForeignKeys        = true;

bool   IsMetadataLoaded;

int MaxColumnTypeLen;
int MaxColumnMemberLen;


static Action<GeneratedTextTransformation,String, String> RenderDtoPropertyName = (tt,c,d) =>
{
	tt.WriteLine("public static readonly string Prop{0} = TypeHelper<{1}>.PropertyName(x => x.{0});", c, d);
};


static string ConvertTypes(string bdType)
{
	switch (bdType)
    {
        case "String":
        {
			return "string";
        }
		case "Decimal":
        {
			return "decimal";
        }
		case "Decimal?":
        {
			return "decimal?";
        }
		case "Double":
        {
			return "double";
        }
		case "Double?":
        {
			return "double?";
        }
		case "Int32":
        {
			return "int";
        }
		case "Int32?":
        {
			return "int?";
        }
		case "Int64":
        {
			return "long";
        }
		case "Int64?":
        {
			return "long?";
        }
    }
	return bdType;
}

static Action<GeneratedTextTransformation,Column> RenderDtoProperty = (tt,c) =>
{
	WriteSummary(tt,c.Description);
	
	var type = ConvertTypes(c.Type);
	
	tt.Write("public {0} {1}", type, c.MemberName);

	if (tt.RenderField)
	{
		tt.Write(";");
		if (c.ColumnType != null)
			tt.Write(tt.LenDiff(tt.MaxColumnMemberLen, c.MemberName));
	}
	else
		tt.Write(" { get; set; }");

	tt.WriteLine("\r\n");
};

static Action<GeneratedTextTransformation,Table, bool> RenderDto = (tt,t, renderForeignKeys) =>
{
	WriteSummary(tt,t.Description);

	if (t.IsView)
	{
		tt.WriteLine("// View");
	}

	tt.Write("public partial class {0}Dto : BaseDto", t.ClassName);
	tt.WriteLine("{");
	
	tt.PushIndent("    ");

	tt.WriteLine("#region [ Property names ]");
	tt.WriteLine("");
	if (t.Columns.Count > 0)
	{
		tt.MaxColumnTypeLen   = t.Columns.Values.Max(_ => _.Type.Length);
		tt.MaxColumnMemberLen = t.Columns.Values.Max(_ => _.MemberName.Length);

		foreach (var c in from c in t.Columns.Values orderby c.ID select c)
		{	
			RenderDtoPropertyName(tt, c.MemberName, t.ClassName+"Dto");
		}

		if (t.ForeignKeys.Count > 0)
		{
			foreach (var key in t.ForeignKeys.Values.Where(k => tt.RenderBackReferences || k.BackReference != null))
			{
				var colName = string.Join(", ", (from c in key.ThisColumns select c.MemberName.Replace("Id",string.Empty)).ToArray());
				RenderDtoPropertyName(tt, colName, t.ClassName+"Dto");
			}	
		}		
	}
	tt.WriteLine("");
	tt.Write("#endregion [ Property names ]");
	tt.WriteLine("");
	tt.WriteLine("");

	if (t.Columns.Count > 0)
	{
		tt.MaxColumnTypeLen   = t.Columns.Values.Max(_ => _.Type.Length);
		tt.MaxColumnMemberLen = t.Columns.Values.Max(_ => _.MemberName.Length);

		foreach (var c in from c in t.Columns.Values orderby c.ID select c)
		{			
			RenderDtoProperty(tt, c);
		}

		if (t.ForeignKeys.Count > 0)
		{
			foreach (var key in t.ForeignKeys.Values.Where(k => tt.RenderBackReferences || k.BackReference != null))
			{
				var colName = string.Join(", ", (from c in key.ThisColumns select c.MemberName.Replace("Id",string.Empty)).ToArray());
				tt.WriteLine("public {0}Dto {0} {{ get; set; }}", colName );
			}	
		}	
	}
	
	tt.PopIndent();
	tt.WriteLine("}");
};

List<string> Usings = new List<string>()
{
	"System",
	"BLToolkit.Data",
	"BLToolkit.Data.Linq",
	"BLToolkit.DataAccess",
	"BLToolkit.Mapping",
	"CQRS.Common",
	"Economy.DataAccess.BlToolkit.Entities",
};

Action<GeneratedTextTransformation> BeforeGenerateModel = _ => {};
Action<GeneratedTextTransformation> AfterGenerateModel  = _ => {};


void GenerateModel()
{
	if (ConnectionString != null) ConnectionString = ConnectionString.Trim();
	if (DataContextName  != null) DataContextName  = DataContextName. Trim();

	if (string.IsNullOrEmpty(ConnectionString)) { Error("ConnectionString cannot be empty."); return; }

	if (string.IsNullOrEmpty(DataContextName))
		DataContextName = "DataContext";

	LoadMetadata();

	WriteLine("//---------------------------------------------------------------------------------------------------");
	WriteLine("// <auto-generated>");
	WriteLine("//    This code was generated by BLToolkit template for T4.");
	WriteLine("//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
	WriteLine("// </auto-generated>");
	WriteLine("//---------------------------------------------------------------------------------------------------");
	WriteLine("/*");

	WriteLine("using System;");
	WriteLine("using CQRS.Common;");
	WriteLine("namespace Economy.Dtos");
	WriteLine("{");
	WriteLine("");
	WriteLine("public class BaseDto { }");
	WriteLine("");
	var tlist   = (from t in Tables.Values orderby t.TableName select t).ToList();
	foreach (var t in tlist)
	{
		WriteLine("");
		RenderDto(this, t, RenderForeignKeys);
	}
	WriteLine("}");
	WriteLine("*/");
}

string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

void WriteSpace(int len)
{
	while (len-- > 0)
		Write(" ");
}

List<T> CreateList<T>(T item)
{
	return new List<T>();
}

Func<System.Data.IDbConnection> GetConnectionObject = () =>
{
	Type connType = null;

	if (DataProviderAssembly != null)
	{
		try
		{
			var assembly = System.Reflection.Assembly.LoadFile(DataProviderAssembly);
			connType = assembly.GetType(ConnectionType) 
				?? assembly.GetType(ConnectionType.Substring(0, ConnectionType.IndexOf(",")));
		}
		catch
		{
		}
	}

	if (connType == null)
		connType = Type.GetType(ConnectionType);

	return (System.Data.IDbConnection)Activator.CreateInstance(connType);
};

System.Data.IDbConnection GetConnection()
{
	var conn = GetConnectionObject();

	conn.ConnectionString = ConnectionString;
	conn.Open();

	return conn;
}

void LoadMetadata()
{
	if (IsMetadataLoaded)
		return;

	IsMetadataLoaded = true;

	if (!string.IsNullOrEmpty(DataProviderAssembly) && !DataProviderAssembly.Contains(":") && DataProviderAssembly.Contains(".."))
	{
		try
		{
			string path = this.Host.ResolvePath("");
			DataProviderAssembly = Path.GetFullPath(Path.Combine(path, DataProviderAssembly));
		}
		catch 
		{
		}
	}

	BeforeLoadMetadata(this);
	LoadServerMetadata();

	if (DatabaseQuote != null)
	{
		foreach (var t in Tables.Values)
		{
			t.TableName = string.Format("{1}{0}{2}", t.TableName, DatabaseQuote.FirstOrDefault(), DatabaseQuote.Skip(1).FirstOrDefault() ?? DatabaseQuote.FirstOrDefault());
			foreach (var c in t.Columns.Values)
			{
				c.ColumnName = string.Format("{1}{0}{2}", c.ColumnName, DatabaseQuote.FirstOrDefault(), DatabaseQuote.Skip(1).FirstOrDefault() ?? DatabaseQuote.FirstOrDefault());
			}
		}
	}

	foreach (var t in Tables.Values)
	{
		if (t.ClassName.Contains(" "))
		{
			var ss = t.ClassName.Split(' ').Where(_ => _.Trim().Length > 0).Select(_ => char.ToUpper(_[0]) + _.Substring(1));
			t.ClassName = string.Join("", ss.ToArray());
		}
	}

	foreach (var t in Tables.Values)
		foreach (var key in t.ForeignKeys.Values.ToList())
			if (!key.KeyName.EndsWith("_BackReference"))
				key.OtherTable.ForeignKeys.Add(key.KeyName + "_BackReference", key.BackReference = new ForeignKey
				{
					KeyName         = key.KeyName    + "_BackReference",
					MemberName      = key.MemberName + "_BackReference",
					AssociationType = AssociationType.Auto,
					OtherTable      = t,
					ThisColumns     = key.OtherColumns,
					OtherColumns    = key.ThisColumns,
				});

	foreach (var t in Tables.Values)
	{
		foreach (var key in t.ForeignKeys.Values)
		{
			if (key.BackReference != null && key.AssociationType == AssociationType.Auto)
			{
				if (key.ThisColumns.All(_ => _.IsPrimaryKey))
				{
					if (t.Columns.Values.Count(_ => _.IsPrimaryKey) == key.ThisColumns.Count)
						key.AssociationType = AssociationType.OneToOne;
					else
						key.AssociationType = AssociationType.ManyToOne;
				}
				else
					key.AssociationType = AssociationType.ManyToOne;

				key.CanBeNull = key.ThisColumns.All(_ => _.IsNullable);
			}
		}
	}

	foreach (var t in Tables.Values)
	{
		foreach (var key in t.ForeignKeys.Values)
		{
			var name = key.MemberName;

			if (key.BackReference != null && key.ThisColumns.Count == 1 && key.ThisColumns[0].MemberName.ToLower().EndsWith("id"))
			{
				name = key.ThisColumns[0].MemberName;
				name = name.Substring(0, name.Length - "id".Length);

				if (!t.ForeignKeys.Values.Select(_ => _.MemberName).Concat(
					 t.Columns.    Values.Select(_ => _.MemberName)).Concat(
					 new[] { t.ClassName }).Any(_ => _ == name))
				{
					name = key.MemberName;;
				}
			}
			
			if (name == key.MemberName)
			{
				if (name.StartsWith("FK_"))
					name = name.Substring(3);

				if (name.EndsWith("_BackReference"))
					name = name.Substring(0, name.Length - "_BackReference".Length);

				name = string.Join("", name.Split('_').Where(_ => _.Length > 0 && _ != t.TableName).ToArray());

				if (name.Length > 0)
					name = key.AssociationType == AssociationType.OneToMany ? PluralizeAssociationName(name) : SingularizeAssociationName(name);
			}

			if (name.Length != 0 &&
				!t.ForeignKeys.Values.Select(_ => _.MemberName).Concat(
				 t.Columns.    Values.Select(_ => _.MemberName)).Concat(
				 new[] { t.ClassName }).Any(_ => _ == name))
			{
				key.MemberName = name;
			}
		}
	}

	if (Tables.Values.SelectMany(_ => _.ForeignKeys.Values).Any(_ => _.AssociationType == AssociationType.OneToMany))
		Usings.Add("System.Collections.Generic");

	var keyWords = new HashSet<string>
	{
		"abstract", "as",       "base",     "bool",    "break",     "byte",     "case",       "catch",     "char",    "checked",
		"class",    "const",    "continue", "decimal", "default",   "delegate", "do",         "double",    "else",    "enum",
		"event",    "explicit", "extern",   "false",   "finally",   "fixed",    "float",      "for",       "foreach", "goto",
		"if",       "implicit", "in",       "int",     "interface", "internal", "is",         "lock",      "long",    "new",
		"null",     "object",   "operator", "out",     "override",  "params",   "private",    "protected", "public",  "readonly",
		"ref",      "return",   "sbyte",    "sealed",  "short",     "sizeof",   "stackalloc", "static",    "struct",  "switch",
		"this",     "throw",    "true",     "try",     "typeof",    "uint",     "ulong",      "unchecked", "unsafe",  "ushort",
		"using",    "virtual",  "volatile", "void",    "while"
	};

	foreach (var t in Tables.Values)
	{
		if (keyWords.Contains(t.ClassName))
			t.ClassName = "@" + t.ClassName;

		if (keyWords.Contains(t.DataContextPropertyName))
			t.DataContextPropertyName = "@" + t.DataContextPropertyName;

		foreach (var col in t.Columns.Values)
			if (keyWords.Contains(col.MemberName))
				col.MemberName = "@" + col.MemberName;
	}


	AfterLoadMetadata(this);
}

Func<string,string> PluralizeAssociationName   = _ => _ + "s";
Func<string,string> SingularizeAssociationName = _ => _;

Action<GeneratedTextTransformation> BeforeLoadMetadata = _ => {};
Action<GeneratedTextTransformation> AfterLoadMetadata  = _ => {};

Dictionary<string,Table> Tables = new Dictionary<string,Table>();

public partial class Table
{
	public string       Owner;
	public string       TableName;
	public string       ClassName;
	public string       DataContextPropertyName;
	public string       BaseClassName;
	public bool         IsView;
	public string		Description;
	public List<string> Attributes = new List<string>();

	public Dictionary<string,Column>     Columns     = new Dictionary<string,Column>();
	public Dictionary<string,ForeignKey> ForeignKeys = new Dictionary<string,ForeignKey>();
}

public partial class Column
{
	public int          ID;
	public string       ColumnName; // Column name in database
	public string       MemberName; // Member name of the generated class
	public bool         IsNullable;
	public bool         IsIdentity;
	public string       Type;       // Type of the generated member
	public string       ColumnType; // Type of the column in database
	public bool         IsClass;
	public DbType       DbType;
	public SqlDbType    SqlDbType;
	public long         Length;
	public int          Precision;
	public int          Scale;
	public string		Description;

	public int          PKIndex = -1;
	public List<string> Attributes = new List<string>();

	public bool IsPrimaryKey { get { return PKIndex >= 0; } }
}

public enum AssociationType
{
	Auto,
	OneToOne,
	OneToMany,
	ManyToOne,
}

public partial class ForeignKey
{
	public string       KeyName;
	public string       MemberName;
	public Table        OtherTable;
	public List<Column> ThisColumns  = new List<Column>();
	public List<Column> OtherColumns = new List<Column>();
	public List<string> Attributes   = new List<string>();
	public bool         CanBeNull    = true;
	public ForeignKey   BackReference;

	private AssociationType _associationType = AssociationType.Auto;
	public  AssociationType  AssociationType
	{
		get { return _associationType; }
		set
		{
			_associationType = value;

			if (BackReference != null)
			{
				switch (value)
				{
					case AssociationType.Auto      : BackReference.AssociationType = AssociationType.Auto;      break;
					case AssociationType.OneToOne  : BackReference.AssociationType = AssociationType.OneToOne;  break;
					case AssociationType.OneToMany : BackReference.AssociationType = AssociationType.ManyToOne; break;
					case AssociationType.ManyToOne : BackReference.AssociationType = AssociationType.OneToMany; break;
				}
			}
		}
	}
}

#>
